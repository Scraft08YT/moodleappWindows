name: 'Release Windows Desktop App'

on:
  push:
    tags:
      - 'desktop-v*'
  workflow_dispatch:

defaults:
  run:
    working-directory: windows-app

jobs:
  release:
    permissions:
      contents: write
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: windows-app/package-lock.json

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: windows-app/src-tauri

      - name: Install frontend dependencies
        run: npm ci

      - name: Verify signing key exists
        shell: pwsh
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
        run: |
          if ([string]::IsNullOrWhiteSpace($env:TAURI_SIGNING_PRIVATE_KEY)) {
            Write-Host "::error::TAURI_SIGNING_PRIVATE_KEY is empty or not set!"
            exit 1
          }
          Write-Host "Signing key is present (length: $($env:TAURI_SIGNING_PRIVATE_KEY.Length) chars)"

      - name: Build Tauri app with signing
        shell: pwsh
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: npx tauri build 2>&1

      - name: Sign bundles manually
        shell: pwsh
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          Write-Host "=== NSIS bundle ==="
          Get-ChildItem src-tauri/target/release/bundle/nsis -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "  $($_.Name) ($($_.Length) bytes)" }
          Write-Host "=== MSI bundle ==="
          Get-ChildItem src-tauri/target/release/bundle/msi -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "  $($_.Name) ($($_.Length) bytes)" }

          # Sign NSIS exe
          $nsisExe = Get-ChildItem src-tauri/target/release/bundle/nsis -Filter "*.exe" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch "\.sig$" } | Select-Object -First 1
          if ($nsisExe) {
            Write-Host "Signing NSIS: $($nsisExe.FullName)"
            npx tauri signer sign "$($nsisExe.FullName)" -k "$env:TAURI_SIGNING_PRIVATE_KEY" -p "$env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD" 2>&1
            if (Test-Path "$($nsisExe.FullName).sig") {
              Write-Host "NSIS signature created successfully!"
            } else {
              Write-Host "::error::Failed to create NSIS signature!"
              exit 1
            }
          }

          # Sign MSI
          $msi = Get-ChildItem src-tauri/target/release/bundle/msi -Filter "*.msi" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch "\.sig$" } | Select-Object -First 1
          if ($msi) {
            Write-Host "Signing MSI: $($msi.FullName)"
            npx tauri signer sign "$($msi.FullName)" -k "$env:TAURI_SIGNING_PRIVATE_KEY" -p "$env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD" 2>&1
            if (Test-Path "$($msi.FullName).sig") {
              Write-Host "MSI signature created successfully!"
            } else {
              Write-Host "::warning::Failed to create MSI signature"
            }
          }

      - name: Collect artifacts and generate latest.json
        id: collect
        shell: pwsh
        run: |
          $version = (Get-Content src-tauri/tauri.conf.json | ConvertFrom-Json).version
          echo "version=$version" >> $env:GITHUB_OUTPUT
          $tag = "${{ github.ref_name }}"
          if (-not $tag -or $tag -eq "") { $tag = "desktop-v$version" }

          # Find NSIS installer and its signature
          $nsisExe = Get-ChildItem src-tauri/target/release/bundle/nsis -Filter "*.exe" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch "\.sig$" } | Select-Object -First 1
          if (-not $nsisExe) { Write-Host "::error::No NSIS .exe found!"; exit 1 }
          Write-Host "Found NSIS: $($nsisExe.Name)"
          echo "nsis_path=$($nsisExe.FullName)" >> $env:GITHUB_OUTPUT

          $nsisExeSig = Get-Item "$($nsisExe.FullName).sig" -ErrorAction SilentlyContinue
          if ($nsisExeSig) {
            Write-Host "Found NSIS sig: $($nsisExeSig.Name)"
            echo "nsis_sig_path=$($nsisExeSig.FullName)" >> $env:GITHUB_OUTPUT
          }

          # Find MSI installer and its signature
          $msi = Get-ChildItem src-tauri/target/release/bundle/msi -Filter "*.msi" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch "\.sig$" } | Select-Object -First 1
          if ($msi) {
            Write-Host "Found MSI: $($msi.Name)"
            echo "msi_path=$($msi.FullName)" >> $env:GITHUB_OUTPUT
            $msiSig = Get-Item "$($msi.FullName).sig" -ErrorAction SilentlyContinue
            if ($msiSig) {
              echo "msi_sig_path=$($msiSig.FullName)" >> $env:GITHUB_OUTPUT
            }
          }

          # URL-encode the filename (spaces -> %20) for the download URL
          $encodedName = [Uri]::EscapeDataString($nsisExe.Name)
          $downloadUrl = "https://github.com/${{ github.repository }}/releases/download/$tag/$encodedName"
          Write-Host "Download URL: $downloadUrl"

          # Read signature content
          $sig = ""
          if ($nsisExeSig) {
            $sig = (Get-Content $nsisExeSig.FullName -Raw).Trim()
            Write-Host "Signature (first 60 chars): $($sig.Substring(0, [Math]::Min(60, $sig.Length)))..."
          } else {
            Write-Host "::error::No NSIS signature found!"
            exit 1
          }

          # Build latest.json
          $latestJson = @{
            version = "v$version"
            notes = "Neue Version der Moodle Desktop App fuer Windows."
            pub_date = (Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ")
            platforms = @{
              "windows-x86_64" = @{
                signature = $sig
                url = $downloadUrl
              }
            }
          } | ConvertTo-Json -Depth 4

          $latestJsonPath = "src-tauri/target/release/bundle/latest.json"
          Set-Content -Path $latestJsonPath -Value $latestJson -Encoding UTF8
          Write-Host "Generated latest.json:"
          Get-Content $latestJsonPath
          echo "latest_json_path=$((Resolve-Path $latestJsonPath).Path)" >> $env:GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: 'Moodle Desktop v${{ steps.collect.outputs.version }}'
          body: 'Neue Version der Moodle Desktop App f√ºr Windows.'
          draft: false
          prerelease: false
          make_latest: true
          files: |
            ${{ steps.collect.outputs.nsis_path }}
            ${{ steps.collect.outputs.msi_path }}
            ${{ steps.collect.outputs.nsis_sig_path }}
            ${{ steps.collect.outputs.msi_sig_path }}
            ${{ steps.collect.outputs.latest_json_path }}
